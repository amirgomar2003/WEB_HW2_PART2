
# مستند پیاده‌سازی backend پروژه Shape Painter

این پروژه با هدف ساخت یک سرور برای اپلیکیشن `Shape Painter` که در بخش قبلی تمرین دوم پیاده‌سازی شده انجام گرفت. با این سرور قابلیت هایی مانند login و ذخیره و بازیابی نشست کاربر به اپلیکیشنی که با `React JS` طراحی کردیم اضافه شد.

---

## مرحله اول: طراحی مدل ها

اول از هرچیزی باید با توجه به Bussiness Logic برنامه باید مدل های مناسبی طراحی میکردیم که بتونن نیاز هامون رو به درستی براورده کنن.

قابلیت هایی که باید توی این بخش به اپلیکیشن نوشته شده‌ توی `React JS` اضافه کنیم متشکل هست از قابلیت login و ذخیره و بازیابی (حداکثر یک) نشست برای کاربران. پس ما به دو موجودیت نشست و کاربر احتیاج خواهیم داشت.

- یه **UserEntity** که شامل username و password و id (برای تعریف کردن روابط) کاربر خواهد بود.
- یه **UserSessionEntity** که شامل تمام اطلاعات برای بازیابی یک نشست خواهد بود. شامل تمام اطلاعاتی که در خروجی تابع `Export` فاز قبل داشتیم +‌ اطلاعات کاربر صاحب نشست.

حالا مدل های مورد نظر رو داشتم و بعد از طراحی `Repository` اونها آماده‌ی استفاده از اونها بودم.

---

## مرحله دوم: نوشتن یک سرویس احراز هویت با استفاده از `Spring Security`.

حالا باید یک سرویس احراز هویت طراحی میکردم که بشه باهاش تشخیص داد کاربری که درحال طراحی هست چه کسیه، تا هم بشه براش نشست قبلی رو با هر بار login موفق بازیابی کرد، و هم بشه نشست‌هاش رو مطابق میلش ذخیره سازی کرد.

طراحی سیستم احراز هویت و توسعه‌ی `Bean` هایی مثل ‍‍`SecurityFilterChain` و حتی `UserDetailService` با استفاده از مثال‌هایی که خود استاد سر کلاس باهاشون تدریس میکردن و حتی یکسری از اونها داخل `CW` هم قرار داده‌ شدن خیلی سریع انجام شد.

---
## مرحله سوم: احراز هویت با استفاده از `UserDetialService` نوشته شده در بخش قبل و ساخت پایانه‌های GET و ‌POST برای مسیر "/session".

حالا توی مسیر محافظت شده‌ی /session پایانه‌هایی طراحی میکنیم که بتونن یک بدنه‌ی `JSON` از نوع `UserSessionEntity` رو دریافت کنن و برای کاربر احراز شده ذخیره کنن، یا Session ذخیره‌شده رو (در صورت وجود) برای درخواست های http از نوع GET تبدیل به فرمت `JSON` کنه و برگردونه.

برای این بخش یکی از چالش‌ها طراحی نوع ذخیره سازی مدل‌ها در پایگاه داده بود،‌ برای این بخش از **هوش مصنوعی** کمک گرفته شد تا بفهمیم مناسب ترین روش ذخیره سازی داده های `JPA` با توجه به دامنه‌ی مساله ما چیه؟ پایگاه داده‌ای که هوش مصنوعی بهم پیشنهاد داد از نوع `h2` و ذخیره سازی در فایل بود. از مزایای این روش پیاده‌سازی به شدت راحت و مناسب بودن اون برای نگهداری داده ها توی محیط توسعه بود، که حتی نیازی به بالا آوردن مجزای پایگاه داده‌هم نداشتیم، اما این روش یک عیب بزرگ هم داره که اون هم این هستش که این روش اصلا برای محیط پروداکشن قابل استفاده نیست و Sacalability نداره، که با توجه به اهداف تمرین و خواسته‌هایی که طراح از ما داشته به این دلیل که نیاز های ما کاملا براورده میشن این ایراد ها قابل چشم پوشی بود.

بعد از طراحی روش پیاده سازی خیلی راحت پایانه‌ها با استفاده از Response Entity از نوع UserSessionEntity و پارس کردن ‍`JSON` های دریافتی انجام شد.

---
## مرحله آخر: انتخاب روش پیاده‌سازی نهایی frontend و backend در کنار هم و انجام تغییرات frontend.

توی مرحله‌ی آخر باید تصمیم میگرفتم که چطور ارتباط بین frontend و backend رو برقرار کنم، بعد از کمی **جست و جو** و مکالمه با **هوش مصنوعی** راه حلی که بهش رسیدم serve کردن frontend از طریق پوشه‌ی static تعریف شده در application.propertis بود، برای این کار باید frontend خودم رو build میکردم و محتویات داخل پوشه‌ی build رو داخل پوشه‌ی static تعریف شده توی spring boot server قرار میدادم. روشی که بعد از کمک گرفتن از هوش مصنوعی انتخاب کردم مزایا و معایب خودش رو داشت. از مزایای اون استفاده کردن از قابلیت های احراز هویت و مدیریت نشست spring security بدون نیاز به پیاده سازی های تکراری و زمان بر بود، دیگه نیازی به تغییرات اساسی توی اپلیکیشن `React JS` نداشتم و این خیلی خوب بود. از معایب این روش هم نیاز به build کردن بعد از هر تغییر برای تست های نهایی و قرار دادن محتویات داخل فولدر مورد نظر بود، که یکم سرعت توسعه‌ی من رو پایین آورده بود، و اینکه وقتی این کار رو انجام میدیم با ایجاد وابستگی بین frontend و backend قابلیت های توسعه‌پذیری و مقیاس‌پذیری رو کاهش میدیم، همچنین به ازای هر تغییر توی frontend سرور هم باید مجددا deploy بشه، همچنین reusability هم برای پایانه‌های backend کاهش پیدا میکنه. در کل با توجه به نیاز ها و مثال هایی که سر کلاس زده‌شد، این روش برای این تمرین مناسب بوده و نیاز های مارو برآورده میکرد.

حالا که روش پیاده‌سازی نهایی هم تایید شد، کافی بود تا عملکرد های load شدن نشست کاربر بعد از ورود موفق، دکمه `Save` و هندلر مناسب که درخواست مناسب رو به backend بفرسته، و دکمه‌ی `Logout` رو اضافه کنم تا کار تکمیل شه. که این بخش هم انجام شد.
